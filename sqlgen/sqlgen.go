package sqlgen

import (
	// pb "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"

	"fmt"
	"strings"

	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
	proto "github.com/golang/protobuf/proto"
)

type pk string

const (
	pkNone = ""
	pkAuto = "auto"
	pkMan  = "man"
)

type field struct {
	structName string
	colName    string
	tableName  string
	comment    string
	pk         pk
	fk         *field
}

// func init() {
// 	generator.RegisterPlugin(New())
// }

type SqlGenerator struct {
	*generator.Generator
	generator.PluginImports
	file       *generator.FileDescriptor
	localName  string
	atleastOne bool
}

func New() generator.Plugin {
	return new(SqlGenerator)
}
func (p *SqlGenerator) Name() string {
	return "crdb"
}

// Init is called once after data structures are built but before
// code generation begins.
func (p *SqlGenerator) Init(g *generator.Generator) {
	p.Generator = g
}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (p *SqlGenerator) Generate(file *generator.FileDescriptor) {
	p.localName = generator.FileName(file)
	p.PluginImports = generator.NewPluginImports(p.Generator)
	p.file = file
	p.Request.Descriptor()
	for _, desc := range p.file.Des {
		p.genFlags(desc)
	}
	// for _, mt := range file.GetMessageType() {
	// 	p.P("//" + *mt.Name + " \n\n")
	// 	p.Sql(mt)
	// }
	// if !p.atleastOne {
	// 	return
	// }
}

func (p *SqlGenerator) genFlags(message *generator.Descriptor) {
	p.test(message)
}
func (p *SqlGenerator) test(message *generator.Descriptor) error {
	for _, field := range message.Field {
		if field.Options != nil {
			continue
		}
		v, err := proto.GetExtension(field.Options, E_Dbcol)
		if err == nil && v.(*string) != nil {
			p.P(fmt.Sprintf("// value ist => %v", v))
		} else {
			// panic("NOT registered" + E_Dbcol.Name)
			p.P(fmt.Sprintf("// failed %v", err))
		}
	}
	return nil
}
func (p *SqlGenerator) Sql(m *descriptor.DescriptorProto) error {
	p.P(`type ` + *m.Name + `Store struct {}`)
	p.P(`type arraySql` + *m.Name + ` []` + *m.Name)
	p.P(`type sql` + *m.Name + ` ` + *m.Name)
	p.scanner(m)
	p.aggregateRow(m)
	p.printFields(m)
	return nil
}

func (p *SqlGenerator) scanner(m *descriptor.DescriptorProto) error {
	p.P(`
//Scan imlementes scanner
func (h *arraySql` + *m.Name + `) Scan(value interface{}) (err error) {
	buff, ok := value.([]byte)
	if !ok {
		return fmt.Errorf("Can't cast %s to []byte", reflect.TypeOf(value))
	}
	return json.Unmarshal(buff, h)
}`)
	return nil
}

func (p *SqlGenerator) getEyevipFieldTags(field *descriptor.FieldDescriptorProto, evField *field) error {
	if field == nil {
		return nil
	}
	if field.Options != nil {
		var v interface{}
		var err error

		v, err = proto.GetExtension(field, E_Dbcol)
		if err == nil && v.(*string) != nil {
			evField.colName = fmt.Sprintf("value ist => %v", v)
		} else {
			// panic("NOT registered" + E_Dbcol.Name)
			evField.comment = fmt.Sprintf("failed %v", err)
		}
		v, err = proto.GetExtension(field.Options, E_Dbpk)
		if err == nil && v.(*string) != nil {
			switch v.(string) {
			case pkAuto:
				evField.pk = pkAuto
			case pkMan:
				evField.pk = pkMan
			default:
				evField.pk = pkNone
			}
		}
	} else {
		evField.comment = "no options on field"
	}
	return nil
}
func (p *SqlGenerator) getFields(m *descriptor.DescriptorProto) []*field {
	ret := []*field{}
	for _, f := range m.GetField() {
		fieldDef := &field{
			structName: m.GetName(),
			tableName:  f.GetName(),
			colName:    *f.Name,
		}
		p.getEyevipFieldTags(f, fieldDef)
		ret = append(ret, fieldDef)
	}
	return ret
}

func (p *SqlGenerator) printFields(m *descriptor.DescriptorProto) error {
	fields := p.getFields(m)
	for _, f := range fields {
		p.P(fmt.Sprintf(`
/*
col: %s
tbld: %s
comment: %s
*/`,
			f.colName,
			f.tableName,
			f.comment,
		))
	}
	return nil
}
func (p *SqlGenerator) aggregateRow(m *descriptor.DescriptorProto) error {
	// for _, ext := range proto.GetExtensions() {
	// 	p.P("// Registred ext: " + ext.Name)
	// }

	p.P(`
	//getAggreatedRow
	func (s *sqlArrayOfChild) getAggreatedRow() string {
	return ` + "`" + `
		SELECT
			"example_children"."example_id" as "id",
			JSON_AGG( JSON_BUILD_OBJECT(
				` +
		func() string {
			lines := []string{}
			for _, f := range m.GetField() {
				lines = append(lines, "'"+*f.Name+"', \"example_children\".\""+*f.Name+"\"")
			}
			return strings.Join(lines, ", ")
		}() + `
			) ) AS "values"
		FROM "example_children"
		GROUP BY "example_children"."example_id"
	` + "`" + `
}`)
	return nil
}

// // GenerateImports produces the import declarations for this file.
// // It is called after Generate.
// func (p *SqlGenerator) GenerateImports(file *generator.FileDescriptor) {
// 	return
// }
