// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: test/test1.proto

package golden

import (
	"context"
	"database/sql"
	fmt "fmt"
	math "math"

	proto "github.com/gogo/protobuf/proto"
	"github.com/roderm/protoc-gen-go-sqlmap/lib/pg"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Store struct {
	conn *sql.DB
}

func NewStore(conn *sql.DB) *Store {
	return &Store{conn}
}

func (s *Store) selectCompany(ctx context.Context, filter pg.Where, withRow func(*Company)) error {
	where, vals := pg.GetWhereClause(filter)
	stmt, err := s.conn.PrepareContext(ctx, `
	SELECT id, name, branch, url, founded 
	FROM company
	`+where)
	if err != nil {
		return err
	}
	cursor, err := stmt.QueryContext(ctx, vals...)
	if err != nil {
		return err
	}
	defer cursor.Close()
	for cursor.Next() {
		var row Company
		err := cursor.Scan(&row.Id, &row.Name, &row.Branch, &row.Url, &row.Founded)
		if err != nil {
			return err
		}
		withRow(&row)
	}
	return nil
}

func (s *Store) selectEmployee(ctx context.Context, filter pg.Where, withRow func(*Employee)) error {
	where, vals := pg.GetWhereClause(filter)
	stmt, err := s.conn.PrepareContext(ctx, `
	SELECT id, company_id, firstname, lastname, email, birthdate 
	FROM employee
	`+where)
	if err != nil {
		return err
	}
	cursor, err := stmt.QueryContext(ctx, vals...)
	if err != nil {
		return err
	}
	defer cursor.Close()
	for cursor.Next() {
		var row Employee
		err := cursor.Scan(&row.Id, &row.CompanyId, &row.Firstname, &row.Lastname, &row.Email, &row.Birthdate)
		if err != nil {
			return err
		}
		withRow(&row)
	}
	return nil
}

func (s *Store) selectProduct(ctx context.Context, filter pg.Where, withRow func(*Product)) error {
	where, vals := pg.GetWhereClause(filter)
	stmt, err := s.conn.PrepareContext(ctx, `
	SELECT id, company_id, name, prod_type, manufactured, sold, price, released
	FROM product
	`+where)
	if err != nil {
		return err
	}
	cursor, err := stmt.QueryContext(ctx, vals...)
	if err != nil {
		return err
	}
	defer cursor.Close()
	for cursor.Next() {
		var row Product
		err := cursor.Scan(&row.Id, &row.CompanyId, &row.Name, &row.ProdType, &row.Manufactured, &row.Sold, &row.Price, &row.Release)
		if err != nil {
			return err
		}
		withRow(&row)
	}
	return nil
}

func (s *Store) Company(ctx context.Context, filter pg.Where, employeeFilter pg.Where, productFilter pg.Where) ([]*Company, error) {
	rows := []*Company{}
	queries_id := []interface{}{}
	employeeTmp := make(map[interface{}]*[]*Employee)
	productTmp := make(map[interface{}]*[]*Product)
	err := s.selectCompany(ctx, filter, func(row *Company) {
		rows = append(rows, row)
		queries_id = append(queries_id, row.Id)
		employeeTmp[row.Id] = &row.Employees
		productTmp[row.Id] = &row.Products
	})

	err = s.selectEmployee(ctx, pg.AND(pg.IN("company_id", queries_id...), employeeFilter), func(row *Employee) {
		*employeeTmp[row.CompanyId] = append(*employeeTmp[row.CompanyId], row)
	})
	if err != nil {
		return rows, err
	}
	err = s.selectProduct(ctx, pg.AND(pg.IN("company_id", queries_id...), productFilter), func(row *Product) {
		*productTmp[row.CompanyId] = append(*productTmp[row.CompanyId], row)
	})
	if err != nil {
		return rows, err
	}
	return rows, nil
}
